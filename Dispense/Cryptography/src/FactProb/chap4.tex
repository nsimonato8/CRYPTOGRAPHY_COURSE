\section{Factoring Problem}
This section explores the state of the art on the factoring problem, that is at the base of the attacks of numerous crypto algorithms. \newline
\subsection{Eratostene's sieve}
In ancient times, a Greek mathematician named Eratostene came up with an intuitive factoring method, based on the extraction of the prime numbers up to a given $N$.
\RestyleAlgo{ruled}
\begin{algorithm}
\KwData{$N \in \mathbb{N}$}
\KwResult{$c$, the list of booleans that represents the prime integers up to $N$}
\caption{Eratostene's sieve}\label{alg:eratostene_sieve}
$c[N] \gets \{True * N\}$\;
$p \gets 2$;
\While{$p^{2} \leq N$}{
    $n \gets p^{2}$\;
    \While{$n \leq N$}{
        $c[N] \gets False$\;
        $n \gets p + n$\;
    }
    \Repeat{$c[p] = True$}{
    $p \gets p + 1$\;
    }
}
\Return{$c$}\;
\end{algorithm}
Let's consider the cost of this algorithm:
\begin{itemize}
    \item For each $p \leq N^{1/2}$, one squaring operation is executed, and
    \[
    l_{p} = \lfloor \frac{N}{p} \rfloor - p \leq \frac{N}{p}
    \]
    sums are executed.
    \item Since $p^{2} + kp \leq N$ for $k \leq l_{p}$, then:
    \begin{align*}
        \sum_{p \leq N^{1/2}} (\operatorname{log}^{2}(p) + \sum_{k=1}^{l_{p}} \operatorname{log}(p^{2} + kp)) & \leq \\
        \sum_{p \leq N^{1/2}} (\operatorname{log}^{2}(p) + \operatorname{log}(N) \sum_{p \leq N^{1/2}} \frac{N}{p})\\
        & = N \operatorname{log}(N) \sum_{p \leq N^{1/2}} \frac{1}{p} + O(N^{1/2} \operatorname{log}(N)) \\
        & = O(N \operatorname{log}(N) \operatorname{log}(\operatorname{log}(N)))
    \end{align*}
\end{itemize}

\subsection{Trial division method}
The simplest algorithm to factorize a given number is to proceed by attempts. \newline
This algorithm tries to do it in the most efficient way possible, but it is still less efficient than the methods that will be proposed later.
\RestyleAlgo{ruled}
\begin{algorithm}
\KwData{$N \in \mathbb{N}$, $L$ the list of prime numbers up to $\sqrt{N}$}
\KwResult{$c$, the list of booleans that represents the prime integers up to $N$}
\caption{Trial-division method}\label{alg:trial_division_method}
$c \gets$ \List{empty}\;
\For{$m \in L$}{
    \If{$m | N$}{
        $c \gets $\Append{$c,m$}\; \Comment{Appends the element $m$ to the list $c$}
    }
}
\Return{$c$}\;
\end{algorithm}
If the list of prime numbers up to $\sqrt{N}$ is provided in input, it is necessary to compute, in the worst case, $\sqrt{N}$ reminders, each one at the cost of $\operatorname{log}^{2}(N)$. \newline
Therefore, the cost of this method is $O(\sqrt{N} \operatorname{log}^{2}(N))$.

\subsection{Fermat factoring method}
This method aims to factorize a number $N$ in two numbers $p, q$, such that $N = p \cdot q$. Also, there must be some $x,y$ such that:
\[
N = x^{2} - y^{2} = (x + y)(x - y)
\]
If $N$ is odd it can be shown that $y = \frac{N - 1}{2}, x = \frac{N + 1}{2}$.
\RestyleAlgo{ruled}
\begin{algorithm}
\KwData{$N \in \mathbb{N}$}
\KwResult{$p,q$}
\caption{Fermat's factoring method}\label{alg:fermat_factoring_method}
$y \gets$ 1\;
\Repeat{$y = \frac{N - 1}{2}$}{
    $x \gets N + y^{2}$\;
    \If{$(\lfloor \sqrt{N + y^{2}}\rfloor)^{2} = N + y^{2}$}{
    \Return{$x,y$}
    }\Comment{Checks if $N + y^{2}$ is a perfect square}
    $y \gets y + 1$\;
}
\end{algorithm}
Let's now consider the cost of this algorithm:
\begin{itemize}
    \item Each iteration has a cost of
    \begin{align*}
        O(\operatorname{log}^{2}(y) + \operatorname{log}^{2}(N + y^{2}) + \operatorname{log}^{3}(N + y^{2})) & = \\
        O(\operatorname{log}^{3}(N + y^{2}))
    \end{align*}
    \item The loop is repeated $O(\operatorname{log}^{A}(N))$ times.
    \item Therefore, the complexity of this algorithm is $O(\operatorname{log}^{A + 3}(N))$ b.o..
\end{itemize}

\subsection{Pollard's rho-method}
The Pollard's $\rho$-method tries to factorize a number $N$, by attempting to find a collision when applying multiple times the same function. That can be summarized as follows:
\begin{itemize}
    \item Let $F: \mathbb{Z}_{N}^{*} \rightarrow \mathbb{Z}_{N}^{*}$.
    \item Let $x_{0} \in \mathbb{Z}_{N}^{*}$ be a randomly chosen seed.
    \item Let $F^{(i)}(x_{0}) = F \circ F \circ \dots \circ F(x_{0})$.
    \item We want to find $i,j$ such that $F^{(i)}(x_{0}) \equiv_{N} F^{(j)}(x_{0})$, and compute $(N, F^{(i)}(x_{0}) - F^{(i)}(x_{0}))$
\end{itemize}
Let's now investigate why this algorithm is correct:
\begin{itemize}
    \item Assume that $p$ is prime and that $p|N$.
    \item Build a sequence of $T$ numbers: $\{F_{x_{0}}\}_{k \leq T \in \mathbb{N}}$
    \item Assume that exists a collision, so:
    \begin{align*}
        \exists F^{(i)}(x_{0}) \equiv_{p} F^{(j)}(x_{0}) \\
        \iff p | F^{(i)}(x_{0}) - F^{(j)}(x_{0}) \\
        \iff (p, F^{(i)}(x_{0}) - F^{(j)}(x_{0})) > 1
    \end{align*}
    \item Due to the Birthday Paradox, we know that:
    \begin{align*}
        \mathbb{P}[\exists F^{(i)}(x_{0}) \equiv_{p} F^{(j)}(x_{0})] = \frac{1}{2} \text{ when } T \leq \sqrt{p} \\
        \text{Since } p|N \implies p \leq \sqrt{N} \implies T = O(\sqrt[4]{N})
    \end{align*}
    \item Therefore, probably we will find the collision.
\end{itemize}
The cost of the algorithm is easy to compute:
\begin{itemize}
    \item We have approximately $O(T^{2}) = O(\sqrt{N})$ steps, that is the quantity necessary to make the Birthday Paraodx hypothesis hold;
    \item Each one has a cost of $O(log^{2}(N))$ b.o.
    \item The expected cost is then O$(\sqrt(N) log^{2}(N))$ b.o.
\end{itemize}

\RestyleAlgo{ruled}
\begin{algorithm}
\KwData{$N,T \in \mathbb{N}, F: \mathbb{Z}_{N}^{*} \rightarrow \mathbb{Z}_{N}^{*}$}
\KwResult{List of $d$, non-trivial factors of $N$}
\caption{Pollard's $\rho$-method}\label{alg:pollard_rho_method}

$x_{0}$ is randomly chosen in $\mathbb{Z}_{N}^{*}$\;
$m \gets 1$\;
$y_{1} \gets F(x_{0})$\;
$y_{2} \gets F(y_{1})$\;
\While{$m \leq T$}{
    $d \gets (N, y_{1} - y_{2})$\;
    \If{$d > 1 \land d < N$}{
        \Return{$d$}
    }
    $m \gets$ m +1\;
    $y_{1} \gets F(y_{1})$\;
    $y_{2} \gets F(F(y_{2}))$\;
}
\end{algorithm}

\subsection{Pomerance's quadratic sieve}
